<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>משחק: תרחץ - שלבים</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Assistant:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #0f172a;
      --surface-color: #1e293b;
      --primary-color: #4f46e5;
      --primary-hover: #6366f1;
      --text-color: #f1f5f9;
      --border-color: #334155;
      --correct-color: #16a34a;
      --incorrect-color: #dc2626;
    }
    body { 
      font-family: 'Assistant', sans-serif; 
      background-color: var(--bg-color); 
      color: var(--text-color); 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      min-height: 100vh; 
      padding: 1rem;
      -webkit-tap-highlight-color: transparent;
    }
    .screen { 
      width: 100%; 
      max-width: 1200px; 
      margin: auto; 
      animation: fadeIn .5s ease-in-out; 
    }
    .screen.hidden { 
      display: none !important; 
    }
    @keyframes fadeIn { 
      from { opacity: 0; transform: translateY(10px); } 
      to { opacity: 1; transform: translateY(0); } 
    }
    .gradient-text { 
      background-image: linear-gradient(to right, #a78bfa, #f472b6);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent; 
    }
    .btn { 
      display: inline-block; 
      font-weight: 700; 
      padding: .75rem 1.5rem; 
      border-radius: .75rem; 
      transition: all .2s; 
      border: none; 
      cursor: pointer;
      text-align: center;
    }
    .btn-primary { 
      background-color: var(--primary-color); 
      color: #fff; 
      box-shadow: 0 4px 14px rgba(0,0,0,0.2);
    }
    .btn-primary:hover:not(:disabled) { 
      background-color: var(--primary-hover); 
      transform: translateY(-2px);
    }
    .btn-secondary { 
      background-color: #374151; 
      color: #fff; 
    }
    .btn-secondary:hover { 
      background-color: #4b5563; 
    }
    .btn:disabled { 
      opacity: .5; 
      cursor: not-allowed; 
      transform: none;
      box-shadow: none;
    }
    #tarchetz-container { 
      background-color: var(--surface-color); 
      padding: 1rem; 
      border-radius: 1rem; 
      box-shadow: 0 10px 25px rgba(0,0,0,0.3);
    }
    #tarchetz-grid { 
      display: grid; 
      gap: 5px; 
      margin: 1rem auto;
      max-width: 600px;
      width: 100%;
    }
    .grid-cell { 
      position: relative; 
      background-color: #334155; 
      border-radius: 6px; 
      aspect-ratio: 1 / 1; 
    }
    .grid-cell.empty { 
      background-color: transparent; 
    }
    .clue-cell { 
      background-color: #475569; 
      display: flex; 
      align-items: center; 
      justify-content: center; 
      font-size: clamp(0.6rem, 2.5vw, 0.9rem);
      font-weight: 600; 
      color: #cbd5e1; 
      text-transform: uppercase; 
      position: relative;
      text-align: center;
      padding: 2px;
    }
    .clue-cell.correct { 
      background-color: var(--correct-color) !important; 
      color: #fff !important; 
    }
    .clue-arrow { 
      position: absolute; 
      width: 14px; 
      height: 14px; 
      color: #9ca3af;
    }
    .arrow-right { right: 4px; top: 50%; transform: translateY(-50%); }
    .arrow-down  { bottom: 4px; left: 50%; transform: translateX(-50%); }
    .clue-cell.correct .clue-arrow {
        color: #fff;
    }
    .answer-cell input {
      direction: rtl; 
      font-family: 'Assistant', sans-serif;
      width: 100%; 
      height: 100%; 
      background-color: #1f2937;
      border: 2px solid var(--border-color); 
      text-align: center; 
      color: var(--text-color);
      font-size: clamp(1.2rem, 5vw, 1.8rem); 
      font-weight: 800; 
      padding: 0; 
      border-radius: 6px;
      caret-color: var(--primary-color);
      transition: all 0.2s ease;
    }
    .answer-cell input:focus { 
      outline: none; 
      background-color: #312e81; 
      border-color: #a78bfa; 
      transform: scale(1.1); 
      z-index: 10; 
    }
    .answer-cell input.correct { 
      border-color: var(--correct-color); 
      background-color: rgba(22, 163, 74, 0.2);
      color: #a7f3d0;
    }
    .answer-cell input.incorrect { 
      border-color: var(--incorrect-color); 
      background-color: rgba(220, 38, 38, 0.2);
    }
    .answer-cell input:disabled {
        opacity: 1;
    }
    .level-lock { 
      opacity: 0.4; 
      pointer-events: none; 
      background-image: none;
      background-color: #4b5563;
    }
    #level-selection-header {
      background-color: var(--surface-color);
      padding: 1rem;
      border-radius: 1rem;
      margin-bottom: 2rem;
    }
  </style>
</head>
<body>

<!-- Level Selection Screen -->
<div id="level-screen" class="screen text-center">
  <div id="level-selection-header">
    <h1 class="text-4xl md:text-5xl font-extrabold gradient-text mb-2">תרחץ</h1>
    <p class="text-lg text-slate-300">תרגום + תשבץ = כיף!</p>
  </div>
  <h2 id="level-difficulty-title" class="text-2xl font-bold mb-6">בחר שלב</h2>
  <div id="levels-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-5 gap-4"></div>
</div>

<!-- Game Screen -->
<div id="game-screen" class="screen hidden w-full">
  <div id="tarchetz-container" class="w-full max-w-2xl mx-auto">
    <div class="flex justify-between items-center p-2 md:p-4">
      <button id="back-to-levels-btn" class="btn btn-secondary text-sm md:text-base">חזור</button>
      <h2 class="text-xl md:text-2xl font-bold text-center">
        <span id="level-name"></span> - <span id="step-num"></span>
      </h2>
      <div id="timer" class="text-xl md:text-2xl font-mono" dir="ltr">00:00</div>
    </div>
    <div id="tarchetz-grid"></div>
  </div>
</div>

<!-- Score Screen -->
<div id="score-screen" class="screen hidden flex flex-col items-center justify-center text-center">
  <div class="p-8 bg-gray-800 rounded-2xl max-w-lg shadow-2xl">
    <h1 id="score-title" class="text-5xl font-bold mb-4 gradient-text">מעולה!</h1>
    <p id="final-score" class="text-2xl md:text-4xl font-bold my-8"></p>
    <div class="flex gap-4">
        <button id="replay-level-btn" class="btn btn-secondary">שחק שוב</button>
        <button id="next-level-btn" class="btn btn-primary">לשלב הבא</button>
    </div>
  </div>
</div>

<script type="module">
  // Firebase Imports
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js";
  import { getAuth, onAuthStateChanged, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js";
  import { getFirestore, doc, getDoc, setDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js";

  // --- DOM ELEMENTS ---
  const levelScreen = document.getElementById('level-screen');
  const gameScreen = document.getElementById('game-screen');
  const scoreScreen = document.getElementById('score-screen');
  const levelsList = document.getElementById('levels-list');
  const gridContainer = document.getElementById('tarchetz-grid');
  const levelName = document.getElementById('level-name');
  const stepNum = document.getElementById('step-num');
  const timerEl = document.getElementById('timer');
  const nextBtn = document.getElementById('next-level-btn');
  const replayBtn = document.getElementById('replay-level-btn');
  const backBtn = document.getElementById('back-to-levels-btn');
  const levelDifficultyTitle = document.getElementById('level-difficulty-title');

  // --- CONSTANTS & STATE ---
  const NUM_LEVELS = 10;
  const WORDS_PER_LEVEL = 5; // Start with 5 words, add one each level

  // Word bank - filled with 30 words per difficulty level
  const bigWordBank = {
    easy: [
        { en: "dog", he: "כלב" }, { en: "cat", he: "חתול" }, { en: "sun", he: "שמש" },
        { en: "house", he: "בית" }, { en: "moon", he: "ירח" }, { en: "water", he: "מים" },
        { en: "bread", he: "לחם" }, { en: "light", he: "אור" }, { en: "good", he: "טוב" },
        { en: "yes", he: "כן" }, { en: "no", he: "לא" }, { en: "dad", he: "אבא" },
        { en: "mom", he: "אמא" }, { en: "boy", he: "ילד" }, { en: "girl", he: "ילדה" },
        { en: "book", he: "ספר" }, { en: "pen", he: "עט" }, { en: "table", he: "שולחן" },
        { en: "chair", he: "כסא" }, { en: "door", he: "דלת" }, { en: "window", he: "חלון" },
        { en: "star", he: "כוכב" }, { en: "flower", he: "פרח" }, { en: "tree", he: "עץ" },
        { en: "sea", he: "ים" }, { en: "head", he: "ראש" }, { en: "hand", he: "יד" },
        { en: "leg", he: "רגל" }, { en: "food", he: "אוכל" }, { en: "night", he: "לילה" }
    ],
    medium: [
        { en: "computer", he: "מחשב" }, { en: "phone", he: "טלפון" }, { en: "car", he: "מכונית" },
        { en: "bicycle", he: "אופניים" }, { en: "airplane", he: "מטוס" }, { en: "train", he: "רכבת" },
        { en: "shirt", he: "חולצה" }, { en: "pants", he: "מכנסיים" }, { en: "shoes", he: "נעליים" },
        { en: "glasses", he: "משקפיים" }, { en: "watch", he: "שעון" }, { en: "key", he: "מפתח" },
        { en: "wallet", he: "ארנק" }, { en: "picture", he: "תמונה" }, { en: "music", he: "מוזיקה" },
        { en: "israel", he: "ישראל" }, { en: "work", he: "עבודה" }, { en: "vacation", he: "חופש" },
        { en: "family", he: "משפחה" }, { en: "friends", he: "חברים" }, { en: "school", he: "ביתספר" },
        { en: "university", he: "אוניברסיטה" }, { en: "restaurant", he: "מסעדה" }, { en: "cafe", he: "ביתקפה" },
        { en: "falafel", he: "פלאפל" }, { en: "hummus", he: "חומוס" }, { en: "country", he: "מדינה" },
        { en: "city", he: "עיר" }, { en: "road", he: "כביש" }, { en: "sky", he: "שמיים" }
    ],
    hard: [
        { en: "democracy", he: "דמוקרטיה" }, { en: "philosophy", he: "פילוסופיה" }, { en: "science", he: "מדע" },
        { en: "technology", he: "טכנולוגיה" }, { en: "economy", he: "כלכלה" }, { en: "politics", he: "פוליטיקה" },
        { en: "history", he: "היסטוריה" }, { en: "literature", he: "ספרות" }, { en: "art", he: "אמנות" },
        { en: "architecture", he: "ארכיטקטורה" }, { en: "psychology", he: "פסיכולוגיה" }, { en: "communication", he: "תקשורת" },
        { en: "environment", he: "סביבה" }, { en: "health", he: "בריאות" }, { en: "education", he: "חינוך" },
        { en: "justice", he: "צדק" }, { en: "freedom", he: "חירות" }, { en: "responsibility", he: "אחריות" },
        { en: "success", he: "הצלחה" }, { en: "failure", he: "כישלון" }, { en: "happiness", he: "אושר" },
        { en: "love", he: "אהבה" }, { en: "hope", he: "תקווה" }, { en: "dream", he: "חלום" },
        { en: "imagination", he: "דמיון" }, { en: "creativity", he: "יצירתיות" }, { en: "leadership", he: "מנהיגות" },
        { en: "inspiration", he: "השראה" }, { en: "challenge", he: "אתגר" }, { en: "solution", he: "פתרון" }
    ]
  };

  const state = {
    difficulty: 'easy',
    user: null,
    progress: { easy: 1, medium: 1, hard: 1 },
    currentStep: 1,
    puzzle: null,
    startTime: null,
    timerInterval: null
  };

  // --- FIREBASE SETUP ---
  let db, auth;
  try {
    const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
    const app = initializeApp(firebaseConfig);
    auth = getAuth(app);
    db = getFirestore(app);
    
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        state.user = user;
        await loadUserData(user.uid);
      } else {
        // If no user, try to sign in with token, otherwise sign in anonymously
        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            try {
                await signInWithCustomToken(auth, __initial_auth_token);
                // onAuthStateChanged will be triggered again
            } catch (e) {
                console.error("Custom token sign-in failed, signing in anonymously.", e);
                await signInAnonymously(auth);
            }
        } else {
            await signInAnonymously(auth);
        }
      }
    });

  } catch (e) {
    console.error("Firebase initialization failed. Running in offline mode.", e);
    // Fallback for local development without firebase config
    initializeAppState();
  }

  async function loadUserData(userId) {
    const userDocRef = doc(db, 'users', userId);
    const docSnap = await getDoc(userDocRef);
    if (docSnap.exists()) {
      const data = docSnap.data();
      state.difficulty = data.difficulty || 'easy';
      state.progress = data.tarchetzProgress || { easy: 1, medium: 1, hard: 1 };
    } else {
      // Create a new document for the user with default progress
      await setDoc(userDocRef, {
        difficulty: state.difficulty,
        tarchetzProgress: state.progress
      });
    }
    initializeAppState();
  }
  
  function initializeAppState() {
      // This function is the main entry point after auth is ready or failed
      renderLevels();
      setupEventListeners();
  }

  // --- UI & GAME FLOW ---
  function showScreen(screen) {
    [levelScreen, gameScreen, scoreScreen].forEach(s => s.classList.add('hidden'));
    screen.classList.remove('hidden');
  }

  function renderLevels() {
    levelsList.innerHTML = '';
    const difficultyMap = { easy: 'קל', medium: 'בינוני', hard: 'קשה' };
    levelDifficultyTitle.textContent = `בחר שלב - ${difficultyMap[state.difficulty]}`;

    for (let i = 1; i <= NUM_LEVELS; i++) {
      const btn = document.createElement('button');
      btn.className = 'btn btn-primary text-xl';
      btn.textContent = i;
      const isLocked = i > state.progress[state.difficulty];
      if (isLocked) {
        btn.classList.add('level-lock');
        btn.innerHTML += '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline-block" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" /></svg>';
      }
      btn.disabled = isLocked;
      btn.addEventListener('click', () => startLevel(i));
      levelsList.appendChild(btn);
    }
    showScreen(levelScreen);
  }

  function startLevel(step) {
    state.currentStep = step;
    const difficultyMap = { easy: 'קל', medium: 'בינוני', hard: 'קשה' };
    levelName.textContent = difficultyMap[state.difficulty];
    stepNum.textContent = `שלב ${step}`;

    // Select random words for the level without repetition
    const wordBank = bigWordBank[state.difficulty];
    const wordsForLevel = [...wordBank].sort(() => 0.5 - Math.random()).slice(0, WORDS_PER_LEVEL + step - 1);

    state.puzzle = generatePuzzle(wordsForLevel);
    if (!state.puzzle) {
        alert("לא הצלחנו ליצור תשבץ עם המילים האלה. נסה לרענן.");
        return;
    }
    renderPuzzle(state.puzzle);
    
    // Start timer
    state.startTime = Date.now();
    clearInterval(state.timerInterval);
    updateTimer(); // run once immediately
    state.timerInterval = setInterval(updateTimer, 1000);
    
    showScreen(gameScreen);
  }

  function updateTimer() {
    const seconds = Math.floor((Date.now() - state.startTime) / 1000);
    const mins = String(Math.floor(seconds / 60)).padStart(2, '0');
    const secs = String(seconds % 60).padStart(2, '0');
    timerEl.textContent = `${mins}:${secs}`;
  }

  // --- PUZZLE GENERATION & RENDERING ---

  function generatePuzzle(words) {
    // Sort words from longest to shortest to make packing easier
    words.sort((a, b) => b.he.length - a.he.length);
    
    const gridSize = Math.max(8, Math.min(15, Math.ceil(Math.sqrt(words.reduce((acc, w) => acc + w.he.length, 0)) * 1.8)));
    let grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null));
    const placedWords = [];

    for (const word of words) {
        let placed = false;
        // Try placing 50 times before giving up on a word
        for (let i = 0; i < 50; i++) {
            const dir = Math.random() > 0.5 ? 'across' : 'down';
            const wordLen = word.he.length + 1; // +1 for the clue cell
            const r = Math.floor(Math.random() * (dir === 'across' ? gridSize : gridSize - wordLen + 1));
            const c = Math.floor(Math.random() * (dir === 'down' ? gridSize : gridSize - wordLen + 1));

            if (canPlace(word, r, c, dir, grid)) {
                placeWord(word, r, c, dir, grid, placedWords.length);
                placedWords.push({ ...word, r, c, dir, index: placedWords.length });
                placed = true;
                break;
            }
        }
    }
    
    return { grid, words: placedWords, size: gridSize };
  }

  function canPlace(word, r, c, dir, grid) {
    const len = word.he.length + 1;
    for (let i = 0; i < len; i++) {
        const rr = dir === 'across' ? r : r + i;
        const cc = dir === 'across' ? c + i : c;
        if (grid[rr][cc] !== null) return false;
    }
    return true;
  }

  function placeWord(word, r, c, dir, grid, wordIndex) {
    // Place clue
    grid[r][c] = { type: 'clue', text: word.en, wordIndex, dir };
    // Place answer cells
    for (let i = 0; i < word.he.length; i++) {
        const rr = dir === 'across' ? r : r + 1 + i;
        const cc = dir === 'across' ? c + 1 + i : c;
        grid[rr][cc] = { 
            type: 'answer', 
            correctLetter: word.he[i], 
            wordIndex, 
            letterIndex: i 
        };
    }
  }

  function renderPuzzle({ grid, size }) {
    gridContainer.innerHTML = '';
    gridContainer.style.gridTemplateColumns = `repeat(${size}, minmax(0, 1fr))`;

    for (let r = 0; r < size; r++) {
      for (let c = 0; c < size; c++) {
        const cellData = grid[r][c];
        const cellElement = document.createElement('div');

        if (cellData === null) {
          cellElement.className = 'grid-cell empty';
        } else if (cellData.type === 'clue') {
          cellElement.className = 'grid-cell clue-cell';
          cellElement.textContent = cellData.text;
          cellElement.dataset.wordIndex = cellData.wordIndex;
          const arrowDir = cellData.dir === 'across' ? 'M17 8l4 4m0 0l-4 4m4-4H3' : 'M16 17l-4 4m0 0l-4-4m4 4V3';
          const arrowClass = cellData.dir === 'across' ? 'arrow-right' : 'arrow-down';
          cellElement.innerHTML += `<svg class="clue-arrow ${arrowClass}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="${arrowDir}"/></svg>`;
        } else if (cellData.type === 'answer') {
          cellElement.className = 'grid-cell answer-cell';
          const input = document.createElement('input');
          input.type = 'text';
          input.maxLength = 1;
          input.autocomplete = 'off';
          input.dataset.wordIndex = cellData.wordIndex;
          input.dataset.letterIndex = cellData.letterIndex;
          input.dataset.correct = cellData.correctLetter;
          cellElement.appendChild(input);
        }
        gridContainer.appendChild(cellElement);
      }
    }
    addInputListeners();
  }

  function addInputListeners() {
    const inputs = Array.from(gridContainer.querySelectorAll('input'));
    inputs.forEach(input => {
      input.addEventListener('input', (e) => handleInput(e.target, inputs));
      input.addEventListener('keydown', (e) => handleKeyDown(e, inputs));
      input.addEventListener('focus', () => input.select());
    });
  }
  
  function handleInput(input, allInputs) {
      const wordIndex = +input.dataset.wordIndex;
      const letterIndex = +input.dataset.letterIndex;
      const word = state.puzzle.words.find(w => w.index === wordIndex);
      
      // Auto-focus next input in the same word
      if (input.value && letterIndex < word.he.length - 1) {
          const nextInput = allInputs.find(i => +i.dataset.wordIndex === wordIndex && +i.dataset.letterIndex === letterIndex + 1);
          if (nextInput) nextInput.focus();
      }

      // Check if word is complete
      const wordInputs = allInputs.filter(i => +i.dataset.wordIndex === wordIndex);
      const isComplete = wordInputs.every(i => i.value);
      
      if (isComplete) {
          evaluateWord(wordIndex, wordInputs);
      } else {
          // Clear validation if user is editing
          wordInputs.forEach(i => i.classList.remove('correct', 'incorrect'));
      }
  }

  function handleKeyDown(e, allInputs) {
    const input = e.target;
    const wordIndex = +input.dataset.wordIndex;
    const letterIndex = +input.dataset.letterIndex;

    if (e.key === 'Backspace' && !input.value && letterIndex > 0) {
      const prevInput = allInputs.find(i => +i.dataset.wordIndex === wordIndex && +i.dataset.letterIndex === letterIndex - 1);
      if (prevInput) prevInput.focus();
    }
  }

  function evaluateWord(wordIndex, wordInputs) {
    const word = state.puzzle.words.find(w => w.index === wordIndex);
    const submittedAnswer = wordInputs.map(i => i.value).join('');
    
    if (submittedAnswer.toLowerCase() === word.he.toLowerCase()) {
        wordInputs.forEach(i => {
            i.classList.remove('incorrect');
            i.classList.add('correct');
            i.disabled = true;
        });
        const clueCell = gridContainer.querySelector(`.clue-cell[data-word-index="${wordIndex}"]`);
        if (clueCell) clueCell.classList.add('correct');
        
        // Check if all words are now correct
        checkLevelCompletion();
    } else {
        wordInputs.forEach(i => {
            i.classList.remove('correct');
            i.classList.add('incorrect');
        });
    }
  }
  
  function checkLevelCompletion() {
      const allInputs = gridContainer.querySelectorAll('input');
      if (Array.from(allInputs).every(i => i.disabled)) {
          finishLevel();
      }
  }

  async function finishLevel() {
    clearInterval(state.timerInterval);
    document.getElementById('score-title').textContent = "כל הכבוד!";
    document.getElementById('final-score').innerHTML = `סיימת את שלב ${state.currentStep} בזמן של ${timerEl.textContent}!`;
    
    nextBtn.disabled = state.currentStep >= NUM_LEVELS;
    if (nextBtn.disabled) {
        nextBtn.textContent = "סיימת הכל!";
    } else {
        nextBtn.textContent = "לשלב הבא";
    }

    showScreen(scoreScreen);

    // Save progress if user is logged in
    if (state.user && state.progress[state.difficulty] === state.currentStep && state.currentStep < NUM_LEVELS) {
      const newProgress = state.currentStep + 1;
      state.progress[state.difficulty] = newProgress;
      try {
        await updateDoc(doc(db, 'users', state.user.uid), {
          tarchetzProgress: state.progress
        });
      } catch (e) {
        console.error("Failed to save progress:", e);
      }
    }
  }

  function setupEventListeners() {
    nextBtn.addEventListener('click', () => {
      if (state.currentStep < NUM_LEVELS) {
        startLevel(state.currentStep + 1);
      }
    });
    replayBtn.addEventListener('click', () => startLevel(state.currentStep));
    backBtn.addEventListener('click', () => renderLevels());
  }

</script>
</body>
</html>